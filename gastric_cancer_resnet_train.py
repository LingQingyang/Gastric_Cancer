# -*- coding: utf-8 -*-
"""Gastric Cancer ResNet Train.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ZHxqDE7NLKI0BIGAXV-ZhorDMvwqrf2o
"""

import os
import pandas as pd
from PIL import Image
import random
import torch
from torch.utils.data import Dataset, DataLoader
import torchvision.transforms as transforms
from torchvision.transforms import functional as F

from google.colab import drive
drive.mount('/content/drive')

image_dir = "/content/drive/MyDrive/Trivial Files/train_org_image_100"
mask_dir = "/content/drive/MyDrive/Trivial Files/train_mask_100"
excel_file = "/content/drive/MyDrive/Trivial Files/train_label.csv"

class HistopathologyDataset(Dataset):
  def __init__(self, image_dir, mask_dir, excel_file, image_transform=None, mask_transform=None, augmentation=None):
    """
    image_dir: 原图路径
    mask_dir: mask路径
    excel_file: Excel路径（包含 image_name 和 label 列）
    image_transform: 对image的预处理
    mask_transform: 对mask的预处理
    augmentation: 数据增广
    """
    self.image_dir = image_dir
    self.mask_dir = mask_dir
    self.labels_df = pd.read_csv(excel_file)
    self.image_transform = image_transform
    self.mask_transform = mask_transform
    self.augmentation = augmentation

    valid_rows = []
    for _, row in self.labels_df.iterrows():
      img_path = os.path.join(image_dir, row['image_name'])
      mask_path = os.path.join(mask_dir, row['image_name'])
      if os.path.exists(img_path) and os.path.exists(mask_path):
        valid_rows.append(row)

    self.labels_df = pd.DataFrame(valid_rows).reset_index(drop=True)
    print(f"有效样本数: {len(self.labels_df)}")

  def __len__(self):
    return len(self.labels_df)

  def __getitem__(self, idx):
    row = self.labels_df.iloc[idx]
    img_name = row['image_name']
    label = row['label']

    img_path = os.path.join(self.image_dir, img_name)
    mask_path = os.path.join(self.mask_dir, img_name)

    image = Image.open(img_path).convert("RGB")
    mask = Image.open(mask_path).convert("L")

    #在PIL阶段做数据增强（保证同步）
    if self.augmentation:
      image, mask = self.augmentation(image, mask)

    if self.image_transform:
      image = self.image_transform(image)

    if self.mask_transform:
      mask = self.mask_transform(mask)

    # 确保mask是long类型（用于CrossEntropyLoss）
    mask = torch.where(mask > 0.5, 1, 0).long()

    # 拼接 image 和 mask → [B, 4, H, W]
    input = torch.cat([image, mask.float()], dim=0)
    return input, label


#Padding
image_fill, mask_fill = 255, 0    # 对image补白边，对mask补黑边

class SquarePad:
  def __init__(self, fill):
    self.fill = fill

  def __call__(self, image):
    w, h = image.size
    max_wh = max(w, h)  # 取最长边
    # 左右上下要补多少
    hp = (max_wh - w) // 2
    vp = (max_wh - h) // 2
    padding = (hp, vp, max_wh - w - hp, max_wh - h - vp)
    return F.pad(image, padding, fill=self.fill, padding_mode="constant")

class Augmentation: #S4 对称群的轨道
  def __call__(self, image, mask):
    # 随机水平翻转
    if random.random() > 0.5:
      image = F.hflip(image)
      mask = F.hflip(mask)

    # 随机垂直翻转
    if random.random() > 0.5:
      image = F.vflip(image)
      mask = F.vflip(mask)

    # 随机旋转
    angle = random.choice([0, 90, 180, 270])
    image = F.rotate(image, angle)
    mask = F.rotate(mask, angle)

    return image, mask

if __name__ == "__main__":

  image_transform = transforms.Compose([
    transforms.Resize(512),
    SquarePad(fill=image_fill),
    transforms.Resize((512, 512)),
    transforms.ToTensor(),
    transforms.Normalize([0.485, 0.456, 0.406],[0.229, 0.224, 0.225])
  ])

    #括号内数字是ImageNet数据集的均值和标准差（分别统计RGB三个通道）。
    #大多数预训练模型（ResNet、ViT、DenseNet）都在ImageNet上训练，所以用同样的归一化方式，以对齐预训练权重。

  mask_transform = transforms.Compose([
    transforms.Resize(512, interpolation=Image.NEAREST),
    SquarePad(fill=mask_fill),
    transforms.Resize((512, 512), interpolation=Image.NEAREST),
    transforms.ToTensor()
  ])

  dataset = HistopathologyDataset(
        image_dir, mask_dir, excel_file,
        image_transform = image_transform,
        mask_transform = mask_transform,
        augmentation = Augmentation()
  )
  dataloader = DataLoader(dataset, batch_size=4, shuffle=True)

  for inputs, labels in dataloader:
    print("Inputs:", inputs.shape)  # [B,4,H,W]
    print("Labels:", labels)        # [B]
    break


#Constructing ResNet
import torchvision.models as models
import torch.nn as nn

class CancerClassifier(nn.Module):
  def __init__(self, num_classes=3):
    super(CancerClassifier, self).__init__()
    # 载入预训练 resnet18
    self.resnet = models.resnet18(pretrained=True)

    # 修改输入层，接受 4 通道 (RGB + mask)
    # 参数来源：“Deep Residual Learning for Image Recognition” (ResNet)
    self.resnet.conv1 = nn.Conv2d(
      in_channels=4,   # 4 通道
      out_channels=64,
      kernel_size=7,
      stride=2,
      padding=3,
      bias=False
    )

    # 修改输出层，改成 num_classes
    in_features = self.resnet.fc.in_features
    self.resnet.fc = nn.Linear(in_features, num_classes)

  def forward(self, x):
    return self.resnet(x)

device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
ResNet = CancerClassifier(num_classes=3).to(device)

loss_fn = nn.CrossEntropyLoss()
optimizer = torch.optim.Adam(ResNet.parameters(), lr=0.0001)
num_epochs = 5
train_losses, train_accs, epoch_num = [], [], []

from tqdm import tqdm  # 进度条

# ResNet训练函数
def train_resnet(ResNet, dataloader, optimizer, loss_fn, device, num_epochs):

  for epoch in range(num_epochs):
    ResNet.train()
    train_loss = 0.0
    correct, total = 0, 0

    for inputs, labels in tqdm(dataloader, desc=f"Train Epoch {epoch+1}/{num_epochs}"):
        inputs, labels = inputs.to(device), labels.to(device)

        optimizer.zero_grad()
        pred_labels = ResNet(inputs)  # [B,num_classes]
        loss = loss_fn(pred_labels, labels)

        loss.backward()
        optimizer.step()

        train_loss += loss.item()
        preds = torch.argmax(pred_labels, dim=1)  # [B]
        correct += (preds == labels).sum().item()
        total += labels.size(0)

    avg_loss = train_loss / len(dataloader)
    accuracy = correct / total

    train_losses.append(avg_loss)
    train_accs.append(accuracy)
    epoch_num.append(epoch+1)

    print(f"Epoch {epoch+1}/{num_epochs} | Train Loss: {avg_loss:.4f} | Accuracy: {accuracy:.4f}")

  return ResNet

trained_resnet = train_resnet(ResNet, dataloader, optimizer, loss_fn, device, num_epochs)

import matplotlib.pyplot as plt
plt.plot(epoch_num, train_losses)
plt.xlabel("Epoch Number")
plt.ylabel("Training Loss (CrossEntropy)")
plt.title("Training Loss Curve")
plt.show()

plt.plot(epoch_num, train_accs)
plt.xlabel("Epoch Number")
plt.ylabel("Prediction Accuracy")
plt.title("Accuracy Curve")
plt.show()

torch.save(trained_resnet.state_dict(), "ResNet.pth")
!cp ResNet.pth /content/drive/MyDrive/AI_Models/
print("✅ Model saved as ResNet.pth to Google Drive")